#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <dlfcn.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <errno.h>

#include "sio.h"

#include "psxcommon.h"

#ifdef TIGER_KING
#include "ndk_log.h"

#ifdef SysMessage
#undef SysMessage
#endif
#endif
extern PcsxConfig   Config;



void SysPrintf(
    const char*     fmt,
    ... )
{
#if 0
    va_list list;
    char    msg[512];

    va_start( list, fmt );
    vsprintf( msg, fmt, list );
    va_end( list );

    if ( Config.PsxOut )
    {
        static char linestart = 1;
        int         l = strlen( msg );

        printf( linestart ? " * %s" : "%s", msg );

        if ( l > 0 && msg[l - 1] == '\n' )
        {
            linestart = 1;
        }
        else
        {
            linestart = 0;
        }
    }

#ifdef EMU_LOG
#ifndef LOG_STDOUT
    fprintf( emuLog, "%s", msg );
#endif
#endif
#endif
}


void SysMessage(
    const char*     fmt,
    ... )
{
#if 0
    va_list list;
    char    msg[512];

    va_start( list, fmt );
    vsprintf( msg, fmt, list );
    va_end( list );

    if ( Config.PsxOut )
    {
        static char linestart = 1;
        int         l = strlen( msg );

        printf( linestart ? " * %s" : "%s", msg );

        if ( l > 0 && msg[l - 1] == '\n' )
        {
            linestart = 1;
        }
        else
        {
            linestart = 0;
        }
    }

#ifdef EMU_LOG
#ifndef LOG_STDOUT
    fprintf( emuLog, "%s", msg );
#endif
#endif
#endif
}


void* SysLoadLibrary( const char* lib )
{
    return dlopen( lib, RTLD_NOW );
}


void* SysLoadSym(
    void*           lib,
    const char*     sym )
{
    return dlsym( lib, sym );
}


const char* SysLibError( void )
{
    return dlerror();
}


void SysCloseLibrary( void* lib )
{
    dlclose( lib );
}


static void SysDisableScreenSaver( void )
{
#if 0
    static time_t           fake_key_timer = 0;
    static char             first_time = 1, has_test_ext = 0, t = 1;
    Display*                display;
    extern unsigned long    gpuDisp;

    display = (Display*)gpuDisp;

    if ( first_time )
    {
        // check if xtest is available
        int a, b, c, d;
        has_test_ext = XTestQueryExtension( display, &a, &b, &c, &d );

        first_time = 0;
    }

    if ( has_test_ext && fake_key_timer < time( NULL ) )
    {
        XTestFakeRelativeMotionEvent( display, t *= -1, 0, 0 );
        fake_key_timer = time( NULL ) + 55;
    }

#endif
}


void SysUpdate( void )
{
#if 0
    PADhandleKey( PAD1_keypressed() );
    PADhandleKey( PAD2_keypressed() );
    SysDisableScreenSaver();
#endif
}

/* ADB TODO Replace RunGui() with StartGui ()*/
void SysRunGui( void )
{
#if 0
    StartGui();
#endif
}


int SysInit( void )
{
#ifdef EMU_LOG
#ifndef LOG_STDOUT
    emuLog = fopen( "emuLog.txt", "wb" );
#else
    emuLog = stdout;
#endif
    setvbuf( emuLog, NULL, _IONBF, 0 );
#endif
    if ( EmuInit() == -1 )
    {
        printf( _( "PSX emulator couldn't be initialized.\n" ) );
        return -1;
    }

    LoadMcds( Config.Mcd1, Config.Mcd2 );   /* TODO Do we need to have this here, or in the calling main() function?? */

    if ( Config.Debug )
    {
        StartDebugger();
    }

    return 0;
}


static void dummy_lace( void )
{
}


void SysReset( void )
{
    LOG_ENTER();

    // rearmed hack: EmuReset() runs some code when real BIOS is used,
    // but we usually do reset from menu while GPU is not open yet,
    // so we need to prevent updateLace() call..
    void*   real_lace = GPUupdateLace;
    GPU_updateLace = dummy_lace;

    LOG_STEP();
    EmuReset();

    LOG_STEP();

    // hmh core forgets this
    CDR_stop();

    GPU_updateLace = real_lace;

    LOG_LEAVE();
}


void SysClose( void )
{
    EmuShutdown();
    ReleasePlugins();

    StopDebugger();

    if ( emuLog != NULL )
    {
        fclose( emuLog );
    }
}


void GPUupdateLace( void )
{
    static u32  lastFPS = 0;
    u32         temp;
    u32         noSkip = 0;

#ifdef ANDROID
    check_paused();

    //LOGD("%d : GPUupdateLace, check_paused done", curFPS); //debug for reset issue. reset does not work yet.
#endif
    if ( displayFrameInfo )
    {
        u32 curDraw = timeGetTime();

        //if(drawn)
        {
            curFPS++;
        }

        if ( curDraw - lastFPSCheck >= 1000 )
        {
            lastFPS = curFPS;   // / BIAS_COUNTERS; // / (Config.PsxType == 0 ? 60 : 50);
            curFPS = 0;
            lastFPSCheck = timeGetTime();
        }
    }

    DisplayCount[1] += ( Config.PsxType == 0 ? 16714 : 20050 ); // DisplayCount[0];
    DrawingCount[2] &= 0xFF;
    DrawingCount[3] &= 0xFF;

    temp = timeGetTime() * 1000;
    if ( (u32) (temp - DisplayCount[2]) > (u32) 2000000 )
    {
        DisplayCount[1] = 0;
        DisplayCount[2] = temp;
    }
    else
    {
        u32 time_delta = temp - DisplayCount[2];
        if ( time_delta < DisplayCount[1] )
        {
            u32 wait_delta = DisplayCount[1] - time_delta;
            if ( wait_delta >= 100 && wait_delta < 100000 )
            {
                usleep( wait_delta );
                noSkip = 1;
            }

            temp = timeGetTime() * 1000;
        }

        if ( DisplayCount[1] > 5000000 )
        {
            DisplayCount[1] = 0;
            DisplayCount[2] = temp;
        }
    }

    if ( !noSkip )
    {
        Skip = DrawingCount[2];
        if ( DrawingCount[2] )
        {
            DrawingCount[2]--;
            Skip = DrawingCount[2];
            return;
        }

        if ( DrawingCount[0] )
        {
            if ( DisplayArea[3] > 240 )
            {
                if ( DrawingCount[3] )
                {
                    DrawingCount[3]--;
                    return;
                }

                DrawingCount[3] = DrawingCount[1];
            }
        }

        DrawingCount[2] = DrawingCount[0];
    }
    else
    {
        Skip = 0;
    }

    u64 now = gp2x_timer_read();
    if ( now - lastFrameDrawnTime < (Config.PsxType == 0 ? 16 : 20) )
    {
        return;
    }

    lastFrameDrawnTime = now;

    if ( (GPU_GP1 & 0x00800000) )
    {
    // Display disabled
        return;
    }

    if ( Skip == 0 )
    {
        //LOGD("CK111: gpuVideoOutput...");
        gpuVideoOutput();

        //LOGD("CK111: gpuVideoOutput done.");
    }

    //gpuVideoOutput();
    if ( displayFrameInfo )
    {
        gp2x_printf( NULL, 0, 0, "FPS: %d RES: %d x %d BITS: %d, Frame=%d", lastFPS, old_res_horz,
                     old_res_vert, (old_rgb24 ? 24 : 16), ++totalFrames );
    }

    //LOGD("call gp2x_video_flip...");
    gp2x_video_flip();

    //LOGD("call gp2x_video_flip done.");
}

